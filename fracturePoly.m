function [poly,triData] = fracturePoly(config,shotMapNew,xinds,yinds,XP,YP,inpoly,ctab)
%fracturePoly fractures polygons for urpec
%
%fracturePoly fractures polygons according to the shotMapNew produced by
%urpect. This function takes the same config struct as urpec. xinds and
%yinds are the indices corresponding to the reduced shot map. XP and
%YP are the meshpoints for the full array, and inpoly is the polygon to
%be fractured. shotMapNew is the exposure map around the parent polygon
%generated by urpect. ctab is the color table generated by urpec.
% 
% poly is an output struct array of polygons.
%
% Within this function, the main data type becomes a cell array of structs,
% each with fields x and y that are column vectors. This is is for
% compatibility with DIVIDEXY.
%

fracDebug=0;

%polyfn=@fixPolys;
polyfn=@fixPolys2;

triCount=0;
c1=0;
c2=0;
f1=0;
bc=0;

triData=struct();

minSize=config.dx*config.fracSize; %Smallest eventual polygon size
fracNum=config.fracNum; %number of times to fracture each polygon each iteration.
dvals=config.dvals;
dx=config.dx;
maxIter=10; %maximum number of fracturing iterations

%First figure out the variation in dose across the polygon
maxDose=max(shotMapNew(:));
minDose=min(shotMapNew(:));

%Maximum dose variation inside of one shape.
dDose=dvals(2)-dvals(1);

poly=struct;
poly(1).x=inpoly.x; %column vector
poly(1).y=inpoly.y; %column vector
poly(1).p=inpoly.p;
poly(1).good=0;
poly(1).layer=ceil(inpoly.layer/2);
[mv,ind]=min(abs(dvals-nanmean(shotMapNew(:))));
poly(1).dose=ind; %dose color
poly(1).sizeX=max(poly(1).x)-min(poly(1).x);
poly(1).sizeY=max(poly(1).y)-min(poly(1).y);

xpold=XP(1,xinds); %1d array
ypold=YP(yinds,1); %1d array

%stash this in case the fracturing goes wrong and we need to triangulate
%the original.
poly_orig=poly;

allGood=0;

nPolys=1;
iter=0;

while ~allGood
    %Show the fracturing status. Also check for empty polygons
    %and zero-area polygons.
    if fracDebug
        figure(777); clf; hold on;
    end
    for j=(length(poly):-1:1)
        if isempty(poly(j).x)
            poly(j)=[];
        elseif polyarea(poly(j).x,poly(j).y)==0
            poly(j)=[];
        else
            if fracDebug
                plot(poly(j).x,poly(j).y,'Color',ctab{poly(j).dose}./255);
            end
        end
    end
    nPolys=length(poly);

    iter=iter+1;
    i=1;
    while i<=nPolys
        i;
        
        if ~poly(i).good
            %The next few lines create the shot map for any not-good
            %polygons. In principle, this has already happened below after
            %the parent polygon was fractured, but this seems to be the
            %fastest way that I can find to do this.
            [xinds,yinds]=shrinkArray(xpold,ypold,[poly(i).x(:) poly(i).y]);
            SMN=shotMapNew(yinds,xinds);
            xpnew=xpold(xinds);
            ypnew=ypold(yinds);
            
            poly(i).sizeX=max(poly(i).x(:))-min(poly(i).x(:));
            poly(i).sizeY=max(poly(i).y(:))-min(poly(i).y(:));
            poly(i).layer=ceil(inpoly.layer/2);   
            
            x=round((poly(i).x-xpnew(1))/(xpnew(2)-xpnew(1)));
            y=round((poly(i).y-ypnew(1))/(ypnew(2)-ypnew(1)));
            subpoly=poly2mask(x(:),y(:),length(ypnew),length(xpnew));
            
            sm=SMN.*subpoly;
            sm(sm==0)=NaN;           
            [mv,ind]=min(abs(dvals-nanmean(sm(:))));
            poly(i).dose= ind;

            maxDose=max(sm(:)); 
            minDose=min(sm(:));
            
            %xdiff=maxDose-minDose;
            %ydiff=xdiff;
            xdiff=max(max(sm,[],2)-min(sm,[],2));
            ydiff=max(max(sm,[],1)-min(sm,[],1));
                      
            shouldFracX=(xdiff>dDose);

            if isempty(shouldFracX)
                shouldFracX=0;
            end
            
            shouldFracY=(ydiff>dDose);

            if isempty(shouldFracY)
                shouldFracY=0;
            end
            canFracX=((poly(i).sizeX/fracNum)>(minSize));
            canFracY=((poly(i).sizeY/fracNum)>(minSize));
            
            %If we can't fracture anymore, call it good.
            if (~canFracX && ~canFracY)
                poly(i).good=1;
            end
            
            if fracDebug
                figure(778); clf; imagesc(xpnew,ypnew,sm);
                set(gca,'YDir','norm');
                title(sprintf('poly %d, xdiff=%2.2f, ydiff=%2.2f, %d, %d, %d, %d, %d, %d',i,xdiff,ydiff,poly(i).sizeX,poly(i).sizeY,canFracX,canFracY,shouldFracX,shouldFracY));
            end
            
            
            % ########## fracturing ##########
            if canFracX || canFracY
                %The (fracNum-1)+1 below is so that when we do not
                %fracture, we divide the polygon into 1 division along x
                %and y, respectively.
                polys2Add=DIVIDEXY(poly(i),canFracX*shouldFracX*(fracNum-1)+1,canFracY*shouldFracY*(fracNum-1)+1);
                polys2Add=polys2Add(:);
            else
                polys2Add={};
            end
            
            % ########## check fractured polys #########   
            bad=0;
            pA=polys2Add; %for debugging
            [polys2Add,bb]=checkPolys(polys2Add,poly(i));
            if bb && ~isempty(polys2Add)
                c1=c1+1;
                bad=1; 
            end
                     
            % ########## clean up fractured polys if needed ##########
            if ~(config.triangulate || config.convexify)
                try
                    pA=polys2Add; %for debugging
                    polys2Add=polyfn(polys2Add);
                catch e
                    f1=f1+1;
                    bad=1;
                end
                
                %Sometimes, fixPoly will not throw an error, but the polygons
                %are messed up. Check their areas again.
                [polys2Add,bb]=checkPolys(polys2Add,poly(i));
                if bb && ~isempty(polys2Add)
                    c2=c2+1;
                    bad=1;
                end
            end
                      
            if bad   
                
                bc=bc+1;
                
                if fracDebug
                    figure(779); clf; hold on;
                    for ip=1:length(polys2Add)
                        try
                            plot(polys2Add{ip}.x,polys2Add{ip}.y);
                        catch
                        end
                    end
                    drawnow;
                end
                
                polys2Add={};
                try                   
                    polys2Add=triangulatePoly(poly(i));
                    [polys2Add,bad]=checkPolys(polys2Add,poly(i));
                    if bad
                        error('');
                    end

                    triCount=triCount+1;

                catch e %if the triangulation goes wrong, game over. Fracture the parent polygon and start over.
                    polys2Add={};
              
                    polys2Add=triangulatePoly(poly_orig);
                    [polys2Add,bad]=checkPolys(polys2Add, poly_orig);
                    polys2Add=polyfn(polys2Add);
                    
                    triCount=triCount+1;
                    
                    %Go back to the original and restart.
                    poly=poly_orig;
                    iter=1;
                    i=1;
                end
                                
            end
                                            
            %If after all this we didn't actually fracture anything,
            %then skip and move on.
            if length(polys2Add)<=1
                polys2Add={};
                i=i+1;
            end
                        
            % ########## check dose variation ##########
            for j=1:length(polys2Add)
                polys2Add{j}.x= polys2Add{j}.x(:);
                polys2Add{j}.y= polys2Add{j}.y(:);
                polys2Add{j}.p= [polys2Add{j}.x(:) polys2Add{j}.y(:)];              
                polys2Add{j}.good=0;
                polys2Add{j}.sizeX=max(poly(i).x)-min(poly(i).x);
                polys2Add{j}.sizeY=max(poly(i).y)-min(poly(i).y);
                polys2Add{j}.layer=ceil(inpoly.layer/2);
                
                [xinds,yinds]=shrinkArray(xpold,ypold,[ polys2Add{j}.x  polys2Add{j}.y]);
                SMN=shotMapNew(yinds,xinds);
                xpnew=xpold(xinds);
                ypnew=ypold(yinds);
                
                x=round(( polys2Add{j}.x-xpnew(1))/(xpnew(2)-xpnew(1)));
                y=round(( polys2Add{j}.y-ypnew(1))/(ypnew(2)-ypnew(1)));
                subpoly=poly2mask(x(:),y(:),length(ypnew),length(xpnew));
                
                sm=SMN.*subpoly;
                sm(sm==0)=NaN;
                maxDose=max(sm(:));
                minDose=min(sm(:));
                
                [mv,ind]=min(abs(dvals-nanmean(sm(:))));
                polys2Add{j}.dose= ind;
                
                if (maxDose-minDose)<dDose %don't need to fracture
                    polys2Add{j}.good=1;
                end
            end
            
            % ########## add fractured polys to the list ##########
            if ~isempty(polys2Add)
                if iter==1
                    for j=1:length(polys2Add)
                        poly(j)=polys2Add{j};
                    end
                else
                    polysEnd=poly(i+1:end);
                    %Add the new polygons in the right place.
                    poly=[poly(1:i-1) polys2Add{:} polysEnd];
                end
            end
            
            %Update the total polygon number and counter (i)
            nPolys=length(poly);
            i=i+length(polys2Add);
            
        else %if we didn't need to fracture it, go to the next polygon.
            i=i+1;
        end
        
    end
    
    if iter==maxIter
        for j=1:length(poly)
            poly(j).good=1;
        end
    end
    
    allGood=all([poly.good]);
    
end

triData.triCount=triCount;
triData.c1=c1;
triData.c2=c2;
triData.f1=f1;
triData.bc=bc;


end

