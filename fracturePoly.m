function [poly,triCount] = fracturePoly(config,shotMapNew,xinds,yinds,XP,YP,inpoly,ctab)
%fracturePoly fractures polygons for urpec
%
%fracturePoly fractures polygons according to the shotMapNew produced by
%urpect. This function takes the same config struct as urpec. xinds and
%yinds are the indices corresponding to the reduced shot map. XP and
%YP are the meshpoints for the full array, and inpoly is the polygon to
%be fractured. shotMapNew is the exposure map around the parent polygon
%generated by urpect. ctab is the color table generated by urpec.
% 
% poly is an output struct array of polygons.
%
% Within this function, the main data type becomes a cell array of structs,
% each with fields x and y that are column vectors. This is is for
% compatibility with DIVIDEXY.
%

fracDebug=0;

triCount=0;

minSize=config.dx*config.fracSize; %Smallest eventual polygon size
fracNum=config.fracNum; %number of times to fracture each polygon each iteration.
dvals=config.dvals;
dx=config.dx;
dy=dx; %This is unfortunate. Fixme. 
maxIter=5; %maximum number of fracturing iterations

%First figure out the variation in dose across the polygon
maxDose=max(shotMapNew(:));
minDose=min(shotMapNew(:));

%Maximum dose variation inside of one shape.
dDose=dvals(2)-dvals(1);

p=inpoly.p;

poly=struct;
poly(1).x=p(:,1); %column vector
poly(1).y=p(:,2); %column vector
poly(1).good=0;
poly(1).layer=ceil(inpoly.layer/2);
[mv,ind]=min(abs(dvals-nanmean(shotMapNew(:))));
poly(1).dose=ind; %dose color
poly(1).sizeX=max(poly(1).x)-min(poly(1).x);
poly(1).sizeY=max(poly(1).y)-min(poly(1).y);

xpold=XP(1,xinds); %1d array
ypold=YP(yinds,1); %1d array

%stash this in case the fracturing goes wrong and we need to triangulate
%the original.
poly_orig=poly;

allGood=0;

really_bad=0;

nPolys=1;
iter=0;

while ~allGood
    %Show the fracturing status. Also check for empty polygons
    %and zero-area polygons.
    if fracDebug
        figure(777); clf; hold on;
    end
    for j=(length(poly):-1:1)
        if isempty(poly(j).x)
            poly(j)=[];
        elseif polyarea(poly(j).x,poly(j).y)==0
            poly(j)=[];
        else
            if fracDebug
                plot(poly(j).x,poly(j).y,'Color',ctab{poly(j).dose}./255);
            end
        end
    end
    nPolys=length(poly);

    iter=iter+1;
    i=1;
    while i<=nPolys
        i;
        if ~poly(i).good
            [xinds,yinds]=shrinkArray(xpold,ypold,[poly(i).x(:) poly(i).y]);
            SMN=shotMapNew(yinds,xinds);
            xpnew=xpold(xinds);
            ypnew=ypold(yinds);
                   
            poly(i).sizeX=max(poly(i).x)-min(poly(i).x);
            poly(i).sizeY=max(poly(i).y)-min(poly(i).y);
                         
            x=round((poly(i).x-xpnew(1))/(xpnew(2)-xpnew(1))); 
            y=round((poly(i).y-ypnew(1))/(ypnew(2)-ypnew(1))); 
            subpoly=poly2mask(x(:),y(:),length(ypnew),length(xpnew));
            
            sm=SMN.*subpoly;       
            sm(sm==0)=NaN;
            maxDose=max(sm(:));
            minDose=min(sm(:));
            xdiff=maxDose-minDose;
            ydiff=maxDose-minDose;
            
%             xline=squeeze(nanmean(sm,1));
%             yline=squeeze(nanmean(sm,2));           
%             xdiff=max(xline)-min(xline);
%             ydiff=max(yline)-min(yline);
            
            if fracDebug
                figure(778); clf; imagesc(xpnew,ypnew,sm);
                set(gca,'YDir','norm');
                title(sprintf('xdiff=%2.2f, ydiff=%2.2f',xdiff,ydiff));
            end
            
            %shouldFracX=(xdiff>dDose/(2+iter*.5));
            shouldFracX=(xdiff>dDose);

            if isempty(shouldFracX)
                shouldFracX=0;
            end
            
            %shouldFracY=(ydiff>dDose/(2+iter*.5));
            shouldFracY=(ydiff>dDose);

            if isempty(shouldFracY)
                shouldFracY=0;
            end
            canFracX=(poly(i).sizeX/fracNum>minSize);
            canFracY=(poly(i).sizeY/fracNum>minSize);
            
            %If we can't fracture anymore, call it good.
            if (~canFracX && ~canFracY)
                poly(i).good=1;
            end
            
            % ########## fracturing ##########
            if canFracX || canFracY
                %The (fracNum-1)+1 below is so that when we do not
                %fracture, we divide the polygon into 1 division along x
                %and y, respectively.
                polys2Add=DIVIDEXY(poly(i),canFracX*shouldFracX*(fracNum-1)+1,canFracY*shouldFracY*(fracNum-1)+1);
                polys2Add=polys2Add(:);
            else
                polys2Add={};
            end
            
            % ########## check fractured polys #########   
            bad=0;
            [polys2Add,bb]=checkPolys(polys2Add,poly(i));
            if bb 
                bad=1; 
            end
                     
            % ########## clean up fractured polys ##########
            try
                polys2Add=fixPolys(polys2Add);
            catch e
                bad=1;
            end
            
            %Sometimes, fixPoly will not throw an error, but the polygons
            %are messed up. Check their areas again.
            [polys2Add,bb]=checkPolys(polys2Add,poly(i));
            if bb 
                bad=1; 
            end
           
            if bad              
                %fprintf('Bad fractured polygon found. Triangulating. \n')
                polys2Add={};
                try                   
                    polys2Add=triangulatePoly(poly(i));
                    [polys2Add,bad]=checkPolys(polys2Add,poly(i));
                    if bad
                        error('');
                    end
                    polys2Add=fixPolys(polys2Add);
                    
                    triCount=triCount+1;

                catch e %if the triangulation goes wrong, game over. Fracture the parent polygon and start over.
                    polys2Add={};
                    %fprintf('Really bad fractured polygon found. Triangulating the original. \n');
               
                    polys2Add=triangulatePoly(poly_orig);
                    [polys2Add,bad]=checkPolys(polys2Add, poly_orig);
                    polys2Add=fixPolys(polys2Add);
                    
                    triCount=triCount+1;
                    
                    %Go back to the original and restart.
                    poly=poly_orig;
                    iter=1;
                    i=1;
                end
                                
            end
                                            
            %If after all this we didn't actually fracture anything,
            %then skip and move on.
            if length(polys2Add)<=1
                polys2Add={};
                i=i+1;
            end
            
            length(polys2Add);
            
            % ########## check dose variation ##########
            for j=1:length(polys2Add)
                polys2Add{j}.x= polys2Add{j}.x(:);
                polys2Add{j}.y= polys2Add{j}.y(:);
                polys2Add{j}.good=0;
                polys2Add{j}.sizeX=max(poly(i).x)-min(poly(i).x);
                polys2Add{j}.sizeY=max(poly(i).y)-min(poly(i).y);
                polys2Add{j}.layer=ceil(inpoly.layer/2);
                 
                x=round((polys2Add{j}.x-xpnew(1))/(xpnew(2)-xpnew(1)));
                y=round((polys2Add{j}.y-ypnew(1))/(ypnew(2)-ypnew(1)));
                subpoly=poly2mask(x(:),y(:),length(ypnew),length(xpnew));
                
                sm=SMN.*subpoly;
                sm(sm==0)=NaN;
                maxDose=max(sm(:));
                minDose=min(sm(:));
                
                [mv,ind]=min(abs(dvals-nanmean(sm(:))));
                polys2Add{j}.dose= ind;
                
                if (maxDose-minDose)<dDose %don't need to fracture
                    polys2Add{j}.good=1;
                end
            end
            
            % ########## add fractured polys to the list ##########
            if ~isempty(polys2Add)
                if iter==1
                    for j=1:length(polys2Add)
                        poly(j)=polys2Add{j};
                    end
                else
                    polysEnd=poly(i+1:end);
                    %Add the new polygons in the right place.
                    poly=[poly(1:i-1) polys2Add{:} polysEnd];
                end
            end
            
            %Update the total polygon number and counter (i)
            nPolys=length(poly);
            i=i+length(polys2Add);
            
        else %if we didn't need to fracture it, go to the next polygon.
            i=i+1;
        end
        
    end
    
    if iter==maxIter
        for j=1:length(poly)
            poly(j).good=1;
        end
    end
    
    allGood=all([poly.good]);
    
end

end

