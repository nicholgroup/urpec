function [poly] = fracturePoly(config,shotMapNew,xinds,yinds,XPold,YPold,inpoly)
%fracturePoly fractures polygons for urpec
%
%fracturePoly fractures polygons according to the shotMapNew produced by
%urpect. This function takes the same config struct as urpec. xinds and
%yinds are the indices corresponding to the reduced shot map. XPold and
%YPold are the meshpoints for the full array, and inpoly is the polygon to
%be fractured. shotMapNew is the exposure map around the parent polygon
%generated by urpect.
% 
% poly is an output struct array of polygons.
%
fracDebug=0;

minSize=config.dx*config.fracSize; %Smallest eventual polygon size
fracNum=config.fracNum; %number of times to fracture each polygon each iteration.
dvals=config.dvals;
dx=config.dx;
dy=dx; %FIXME

%First figure out the variation in dose across the polygon
maxDose=max(shotMapNew(:));
minDose=min(shotMapNew(:));

%Maximum dose variation inside of one shape.
dDose=dvals(2)-dvals(1);

p=inpoly.p;

poly=struct;
poly(1).x=p(:,1); %column vector
poly(1).y=p(:,2); %column vector
poly(1).good=0;
poly(1).layer=ceil(inpoly.layer/2);
[mv,ind]=min(abs(dvals-nanmean(shotMapNew(:))));
poly(1).dose=ind; %dose color

allGood=0;

nPolys=1;
iter=0;

while ~allGood
    %Show the fracturing status. Also check for empty polygons
    %and zero-area polygons.
    if fracDebug
        figure(777); clf; hold on;
    end
    for j=(length(poly):-1:1)
        if isempty(poly(j).x)
            poly(j)=[];
        elseif polyarea(poly(j).x,poly(j).y)==0
            poly(j)=[];
        else
            if fracDebug
                plot(poly(j).x,poly(j).y,'Color',ctab{poly(j).dose}./255);
            end
        end
    end
    nPolys=length(poly);
    %drawnow;
    iter=iter+1;
    i=1;
    while i<=nPolys
        i;
        if ~poly(i).good
            poly(i).sizeX=max(poly(i).x)-min(poly(i).x);
            poly(i).sizeY=max(poly(i).y)-min(poly(i).y);

            XPnew=XPold(yinds,xinds)+dx/2;  %2d array
            YPnew=YPold(yinds,xinds)+dy/2; %2d array
            xpnew=XPnew(1,:); %1d array
            ypnew=YPnew(:,1); %1d array
            
            xline=squeeze(nanmean(shotMapNew,1));
            yline=squeeze(nanmean(shotMapNew,2));
            xdiff=max(xline)-min(xline);
            ydiff=max(yline)-min(yline);
            
            shouldFracX=(xdiff>dDose/(2+iter*.5));
            if isempty(shouldFracX)
                shouldFracX=0;
            end
            shouldFracY=(ydiff>dDose/(2+iter*.5));
            if isempty(shouldFracY)
                shouldFracY=0;
            end
            canFracX=(poly(i).sizeX/fracNum>minSize);
            canFracY=(poly(i).sizeY/fracNum>minSize);
            
            %Actually do the fracturing
            if canFracX || canFracY
                polys2Add=DIVIDEXY(poly(i),canFracX*shouldFracX*(fracNum-1)+1,canFracY*shouldFracY*(fracNum-1)+1);
                polys2Add=polys2Add(:);
            else
                polys2Add={};
            end
            
            %Check for empty polys and polys of zero area and get rid of them
            for j=(length(polys2Add):-1:1)
                
                if isempty(polys2Add{j}) || any(size(polys2Add{j}.x)~=size(polys2Add{j}.y))
                    polys2Add(j)=[];
                end
                
                try
                    if polyarea(polys2Add{j}.x,polys2Add{j}.y)<1e-5
                        polys2Add(j)=[];
                    end
                end
                
            end
            
            %go through the polys again and try to clean them up
            for j=(length(polys2Add):-1:1)
                
                %Clean up the fractured polys here.
                bad=0;
                %[polys2Add{j}.x,polys2Add{j}.y]=fixPoly(polys2Add{j}.x,polys2Add{j}.y);
                
                
                try
                    [polys2Add{j}.x,polys2Add{j}.y]=fixPoly(polys2Add{j}.x,polys2Add{j}.y);
                catch e
                    %fixPoly throws and error if the polygon is so messed
                    %up that it can't fix it. In this case, we should
                    %triangulate the parent polygon so we can continue.
                    fprintf('Bad fractured polygon found. Triangulating. \n')
                    bad=1;
                    polys2Add={};
                    polyin=polyshape(poly(i).x,poly(i).y);
                    %fracture it into triangles
                    T = triangulation(polyin);
                    CL=T.ConnectivityList;
                    for tt=1:size(T.ConnectivityList,1)
%                         xnew=[poly(i).x(CL(tt,:))' poly(i).x(CL(tt,1))];
%                         ynew=[poly(i).y(CL(tt,:))' poly(i).y(CL(tt,1))];   
                        xnew=poly(i).x(CL(tt,:)); xnew=xnew(:); %convert to column vector
                        ynew=poly(i).y(CL(tt,:)); ynew=ynew(:); %convert to column vector
                        [polys2Add{tt}.x,polys2Add{tt}.y]=fixPoly(xnew,ynew);
                    end
                    
                end
                
                %Something wrong happened, and we had to triangulate.
                if bad
                    break
                end
                
            end
            
            %If after all this we didn't actually fracture anything,
            %then skip and move on.
            if length(polys2Add)<=1
                polys2Add={};
                i=i+1;
            end
            
            length(polys2Add);
            
            %Go through the new polygons and find out if
            %they're good.
            for j=1:length(polys2Add)
                polys2Add{j}.x= polys2Add{j}.x';
                polys2Add{j}.y= polys2Add{j}.y';
                polys2Add{j}.good=0;
                polys2Add{j}.sizeX=max(poly(i).x)-min(poly(i).x);
                polys2Add{j}.sizeY=max(poly(i).y)-min(poly(i).y);
                polys2Add{j}.layer=ceil(inpoly.layer/2);
                 
                x=round((polys2Add{j}.x-xpnew(1))/(xpnew(2)-xpnew(1)));
                y=round((polys2Add{j}.y-ypnew(1))/(ypnew(2)-ypnew(1)));
                subpoly=poly2mask(x',y',length(ypnew),length(xpnew));
                
                sm=shotMapNew.*subpoly;
                sm(sm==0)=NaN;
                maxDose=max(sm(:));
                minDose=min(sm(:));
                
                [mv,ind]=min(abs(dvals-nanmean(sm(:))));
                polys2Add{j}.dose= ind;
                
                if (maxDose-minDose)<dDose %don't need to fracture
                    polys2Add{j}.good=1;
                end
            end
            
            %Add the new polygons back to the total list of polygons
            if ~isempty(polys2Add)
                if iter==1
                    for j=1:length(polys2Add)
                        poly(j)=polys2Add{j};
                    end
                else
                    polysEnd=poly(i+1:end);
                    %Add the new polygons in the right place.
                    poly=[poly(1:i-1) polys2Add{:} polysEnd];
                end
            end
            
            %Update the total polygon number and counter (i)
            nPolys=length(poly);
            i=i+length(polys2Add);
            
        else %if we didn't need to fracture it, go to the next polygon.
            i=i+1;
        end
        
        %If we can't fracture anymore, call it good.
        if (~canFracX && ~canFracY)
            poly(i).good=1;
        end
    end
    
    if iter==fracNum
        for j=1:length(poly)
            poly(j).good=1;
        end
    end
    allGood=all([poly.good]);
    
end



end

